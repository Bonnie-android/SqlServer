Concurrent Transactions In SQL Server

A transaction is a group of commands working together as a single unit of work.
Transactions are designed to change the data in a database and to always leave the data in a consistent state.
Either all of the commands execute and the final result committed or all of the changes are rolled back to their original state.
It is common for many transactions to run concurrently and to be accessing the same tables.
This leads to concurrency problems when two or more transactions attempt to access the same table for an update.
The common types of concurrency problems are Dirty Reads, Lost Updates, Non-repeatable Reads and Phantom Reads.
The isolation level that is chosen for a transaction defines the degree to which one transaction must be isolated from resources or data modifications made by other transactions.
Depending on the isolation level chosen there will be varying degrees of performance and concurrency problems.
The Sql Server Transaction Isolation Levels are Read Uncommitted, Read Committed, Repeatable Read, Snapshot and Serializable.
Read Uncommitted is the fastest since it involves fewer locks on the tables involved in the transaction. 
Thie level allows many transactions to run at the same time.
Read Uncommitted is the source of Dirty Reads, Lost Update, Non-repeatable Reads, and Phantom Reads however.
Read Committed is the default setting for transactions in Sql Server.
The Read Committed level of transaction isolation will prevent dirty reads but it will not prevent lost updates, non-repeatable reads or phantom reads.
Repeatable Read transaction isolation level will prevent dirty reads, lost updates, non-repeatable reads but will not prevent phantom reads.
Snapshot transaction isolation level will prevent all of the concurrency problems by going down and causing a rollback if these problems arise.
Serializable transaction isolation level is the strictest of all the transaction isolation levels. 
It has an exclusive lock on the tables being updated until the transaction is finished. Other transactions must wait until the transaction completes.
Because of this the Serializable isolation level is the slowest.

DIRTY READS
Dirty reads occur when one transaction is allowed to read the uncommitted data from another transaction. 
If the transaction in progress is rolled back then the information read from the buffer is no longer valid.
This occurs with transaction isolation level read uncommitted and this is the only transaction isolation level having this side effect.
Transactions are very fast when run at this level.
> set transaction isolation level read uncommitted
It is also possible to read uncommitted data by using the NOLOCK table hint. 
> select * from tblProducts (NOLOCK) where id = 100.

LOST UPDATES
A lost update transaction occurs when two or more transactions update the same data at the same time. 
An inventory table may be updated many times as sales occur. 
There will be many sales transactions occuring simultaneously on the same data.
A lost update occurs when one of the transactions overwrites the other transaction with the information in its buffer.
This problem occurs with the transaction isolation levels read uncommitted and read committed only.
It does not occur with higher transaction isolation levels.

If the transaction isolation level is set to Repeatable Read then Sql Server will choose the transaction requiring the least amount of work to undo and will kill the process.
The system will give a msg 1205 similar to the following:
Msg 1205, Level 13, State 51, Line 10
Transaction (Process ID 56) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.
In the event of a conflict the transaction won't run.

NON REPEATABLE READS
A non-repeatable read happens when one transaction reads the same data twice as part of the transaction but another transaction intervenes in between reads and updates the data.
The two reads from the first transaction will not be the same.
To prevent this type of problem use transaction isolation level Repeatable Read or higher isolation level.
For repeatable read there will be additional locks placed on the tables during the first transaction that cause the second transaction to wait until the first transaction has completed.

PHANTOM READS
Phantom reads occur when the number of rows that are read are not the same within a transaction. 
Transaction 1 reads data from a table. Transaction 2 then adds or deletes rows from that block and updates the table.
Transaction 1 does an additional read on that same block of data but now rows have now been added or deleted by transaction 2.
This can be prevented by using transaction isolation levels Snapshot or Serializable.
The transaction isolation level Repeatable Read does not prevent inserts/deletes of the block of data and will not prevent a phantom read.
The transaction isolation level Serializable issues a range lock.
A range lock occurs when the where clause of a query contains a range. 
This range of records is locked throughout the transaction until it is complete.









